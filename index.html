<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Resonance: Stealth</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            user-select: none;
        }
        canvas { display: block; }
        
        /* UI 层 */
        #ui-layer {
            position: absolute; top: 20px; left: 20px;
            color: #33ccff; pointer-events: none; z-index: 10;
        }
        .hud-row {
            margin-bottom: 8px; font-size: 16px;
            text-shadow: 0 0 5px rgba(51, 204, 255, 0.5);
        }
        .val-warn { color: #ff3333; text-shadow: 0 0 5px #ff3333; }
        
        #freq-box {
            border: 2px solid #33ccff; padding: 5px 10px;
            display: inline-block; background: rgba(0,20,40,0.8);
            font-weight: bold; font-size: 20px; transition: color 0.2s;
        }
        
        /* 频率分析仪浮动UI */
        .analyzer-tag {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #33ccff;
            padding: 6px;
            color: #fff;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            display: none;
            box-shadow: 0 0 10px #33ccff;
            z-index: 100;
        }
        .analyzer-bar {
            width: 80px; height: 6px; background: #333; margin: 4px 0; position: relative; border-radius: 2px;
        }
        .analyzer-pip {
            width: 4px; height: 10px; background: #fff; position: absolute; top: -2px; transition: left 0.1s;
        }
        .analyzer-center {
            width: 2px; height: 10px; background: #33ccff; position: absolute; left: 40px; top: -2px;
        }
        .analyzer-text {
            font-size: 12px; font-weight: bold; text-align: center;
        }

        /* 交互提示 (通用) */
        .interact-hint {
            position: absolute; display: none;
            color: #fff; font-weight: bold; font-size: 14px;
            text-shadow: 0 0 5px #fff; border: 1px solid #fff;
            padding: 2px 6px; background: rgba(0,0,0,0.8);
            transform: translate(-50%, -150%);
            z-index: 101;
        }
        /* 处决特定样式 */
        #execute-hint { color: #ff0000; border-color: #ff0000; text-shadow: 0 0 5px #ff0000; }
        /* 拾取特定样式 */
        #pickup-hint { color: #00ff00; border-color: #00ff00; text-shadow: 0 0 5px #00ff00; }

        /* 受伤/过载红屏 */
        #screen-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; z-index: 5;
            transition: opacity 0.1s;
        }

        /* 操作指南优化 */
        .controls {
            position: absolute; bottom: 20px; left: 20px;
            color: #aaa; font-size: 13px; z-index: 10;
            background: rgba(0, 10, 20, 0.8);
            padding: 10px;
            border-left: 3px solid #33ccff;
            line-height: 1.6;
        }
        .key-btn {
            color: #fff; font-weight: bold; background: #333; padding: 1px 4px; border-radius: 3px; font-size: 12px;
        }
        .highlight { color: #33ccff; font-weight: bold; }
    </style>
</head>
<body>

<div id="screen-flash"></div>

<div id="ui-layer">
    <div class="hud-row" id="hp-row">HEALTH: <span id="hp-val">60/60</span></div>
    <div class="hud-row">ENERGY: <span id="energy-val">100/100</span></div>
    <div class="hud-row">TUNER: <span id="freq-box">150 Hz</span></div>
    <div class="hud-row" id="msg-log" style="color:#ffaa00; height:20px; font-size:14px;">System Online.</div>
</div>

<div id="world-ui-container"></div>
<!-- 交互提示 -->
<div id="execute-hint" class="interact-hint">[E] SIPHON CORE</div>
<div id="pickup-hint" class="interact-hint">[E] PICKUP ENERGY</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiContainer = document.getElementById('world-ui-container');
const executeHint = document.getElementById('execute-hint');
const pickupHint = document.getElementById('pickup-hint');
const screenFlash = document.getElementById('screen-flash');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- 配置参数 ---
const CFG = {
    // 玩家
    pSpeed: 3,
    pViewDist: 280,
    pViewAngle: Math.PI / 2.5,
    playerRadius: 14,          // 玩家碰撞半径（用于波纹命中与分割）
    maxHp: 60,
    maxEnergy: 100,         // 主能量上限
    healCost: 30,
    healVal: 30,
    energyFlaskVal: 50, // 能量瓶恢复量
    
    // 扫描与波
    forcedWaveCost: 15,
    overloadDmgRatio: 1.3,
    waveSpeed: 5,
    waveMaxDist: 1500,  // 增大扫描范围
    
    // 聚焦参数
    focusSpeed: 0.02,
    minSpread: 0.08, 
    maxSpread: Math.PI * 2,
    analyzeThreshold: 0.5,
    
    // 频率
    freqMin: 100,
    freqMax: 300,
    perfectResTol: 5,  // 完美共振容差（±5Hz）
    normalResTol: 15,  // 普通共振容差（±15Hz） 
    
    // 敌人
    eSpeedPatrol: 0.6,
    eSpeedChase: 1.5,
    stunTime: 400, 
    dmgVal: 20,
    dmgCD: 60,
    resCooldown: 120,
    
    // 波纹能量
    baseWaveEnergy: 10000,   // 波纹固定基础能量N
    energyThreshold: 0.1,    // 过载能量阈值比例
    initialRadius: 5,         // 初始半径
    
    // 信息等级阈值（基于totalEnergy）
    infoLevelClear: 500,      // 高于此值：清晰轮廓（低于则为模糊轮廓）
    infoLevelAnalyze: 2000,   // 高于此值：显示分析UI
    infoLevelLong: 8000,      // 高于此值：长期显示（低于则为短暂显示）
    
    // 阻挡物
    wallFreqs: [150, 200, 250],  // 墙壁频率选项
    wallColors: {              // 墙壁颜色映射
        150: '#333333',
        200: '#666666', 
        250: '#999999'
    },
    
    // 相机
    cameraFOV: 1.4,             // 视野缩放（1.0 = 正常，>1.0 = 放大，<1.0 = 缩小）
    cameraFollowSpeed: 0.1,     // 相机跟随速度（0-1，越大跟随越快）
    cameraSmoothing: true       // 是否启用平滑跟随
};

// --- Instruction 定义 ---
const INSTRUCTIONS = [
    { id: 0, text: "WASD移动\n鼠标移动转向", distance: 0 },
    { id: 1, text: "波纹生物都有自己的频率\n它们会被同频的波纹吸引", distance: 50 },
    { id: 2, text: "短按空格释放波\n长按空格聚焦波\n波会消耗能量", distance: 200 },
    { id: 3, text: "转动鼠标滚轮调整频率\n频率越高、角度越聚焦\n消耗能量越大", distance: 350 },
    { id: 4, text: "低频会穿过\n高频会阻挡\n同频会共振", distance: 400 },
    { id: 5, text: "聚焦共振波能够使波纹生物过载\n利用这个机会靠近并解决它们", distance: 500 },
    { id: 6, text: "生物共振后会受迫释放波纹\n先消耗能量，然后是生命", distance: 600 },
    { id: 7, text: "随时捡起能量瓶\n按R使用备用能量", distance: 650 },
    { id: 8, text: "在危急时刻\n按F消耗能量，恢复生命", distance: 750 },
];

// --- 游戏状态 ---
const state = {
    p: { x: canvas.width/2, y: canvas.height/2, a: 0, hp: CFG.maxHp, en: CFG.maxEnergy, reserveEn: 0, invuln: 0, resCool: 0 },
    keys: { w:0, a:0, s:0, d:0, space:0, f:0, r:0 },
    mouse: { x:0, y:0 },
    freq: 150,
    focusLevel: 0,
    isCharging: false,
    camera: { x: canvas.width/2, y: canvas.height/2 }, // 相机位置
    entities: {
        walls: [], enemies: [], waves: [], echoes: [], particles: [], items: [], wallEchoes: [], instructions: [] // 新增物品列表、墙壁回声和教学文本
    }
};

// --- 初始化 ---
function generateInstructions() {
    const spawnX = canvas.width / 2;
    const spawnY = canvas.height / 2;
    const instructions = [];
    
    for (let i = 0; i < INSTRUCTIONS.length; i++) {
        const inst = INSTRUCTIONS[i];
        let x, y, attempts = 0;
        let valid = false;
        
        // 尝试找到不重叠的位置
        while (!valid && attempts < 100) {
            attempts++;
            // 从出生点向外辐射生成（使用固定角度分布）
            const angle = (i * Math.PI * 2 / INSTRUCTIONS.length) + (Math.random() - 0.5) * 0.8;
            x = spawnX + Math.cos(angle) * inst.distance;
            y = spawnY + Math.sin(angle) * inst.distance;
            
            // 确保在画布内
            if (x < 100 || x > canvas.width - 100 || 
                y < 100 || y > canvas.height - 100) {
                continue;
            }
            
            // 检查是否与其他instruction重叠
            let overlapsInst = false;
            for (const other of instructions) {
                if (dist(x, y, other.x, other.y) < 150) {
                    overlapsInst = true;
                    break;
                }
            }
            
            if (!overlapsInst) {
                valid = true;
            }
        }
        
        if (valid) {
            instructions.push({
                id: inst.id,
                x: x,
                y: y,
                text: inst.text,
                distance: inst.distance
            });
        }
    }
    
    return instructions;
}

function init() {
    state.entities.walls = [];
    state.entities.items = []; // Reset items
    state.entities.instructions = []; // Reset instructions
    
    // 先生成 instructions
    state.entities.instructions = generateInstructions();

    // 在地图四周生成边界墙，让玩家看不到画布边缘
    const borderThickness = 60;
    const borderFreq = CFG.wallFreqs[CFG.wallFreqs.length - 1]; // 使用最高频率作为边界阻挡
    const borderColor = CFG.wallColors[borderFreq];
    // 上边界
    state.entities.walls.push({
        x: -borderThickness, y: -borderThickness,
        w: canvas.width + borderThickness*2, h: borderThickness,
        blockFreq: borderFreq, color: borderColor
    });
    // 下边界
    state.entities.walls.push({
        x: -borderThickness, y: canvas.height,
        w: canvas.width + borderThickness*2, h: borderThickness,
        blockFreq: borderFreq, color: borderColor
    });
    // 左边界
    state.entities.walls.push({
        x: -borderThickness, y: 0,
        w: borderThickness, h: canvas.height,
        blockFreq: borderFreq, color: borderColor
    });
    // 右边界
    state.entities.walls.push({
        x: canvas.width, y: 0,
        w: borderThickness, h: canvas.height,
        blockFreq: borderFreq, color: borderColor
    });
    
    // 生成墙壁（增加数量到12个，并避免与instructions重叠）
    let attempts = 0;
    while(state.entities.walls.length < 12 && attempts < 300) {
        attempts++;
        const w = rand(80, 200);
        const h = rand(80, 200);
        const x = rand(100, canvas.width-200);
        const y = rand(100, canvas.height-200);
        
        let overlap = false;
        
        // 检查与其他墙壁重叠
        for (const other of state.entities.walls) {
            if (x < other.x + other.w + 20 && x + w + 20 > other.x && 
                y < other.y + other.h + 20 && y + h + 20 > other.y) {
                overlap = true; break;
            }
        }
        
        // 检查与出生点重叠
        if (!overlap) {
            const px = canvas.width/2; const py = canvas.height/2;
            if (x < px + 150 && x + w > px - 150 && y < py + 150 && y + h > py - 150) overlap = true;
        }
        
        // 检查与instructions重叠
        if (!overlap) {
            for (const inst of state.entities.instructions) {
                if (x < inst.x + 100 && x + w > inst.x - 100 &&
                    y < inst.y + 50 && y + h > inst.y - 50) {
                    overlap = true;
                    break;
                }
            }
        }
        
        if (!overlap) {
            const blockFreq = CFG.wallFreqs[Math.floor(Math.random() * CFG.wallFreqs.length)];
            state.entities.walls.push({
                x, y, w, h, 
                blockFreq: blockFreq,
                color: CFG.wallColors[blockFreq]
            });
        }
    }

    for(let i=0; i<5; i++) spawnEnemy();
    
    // 生成能量瓶
    for(let i=0; i<8; i++) spawnItem('energy');
    
    // 初始化相机位置为玩家位置
    state.camera.x = state.p.x;
    state.camera.y = state.p.y;
    
    updateUI();
    requestAnimationFrame(loop);
}

function spawnEnemy() {
    let ex, ey, ok=false;
    while(!ok) {
        ex = rand(50, canvas.width-50); ey = rand(50, canvas.height-50);
        if(dist(ex,ey,state.p.x,state.p.y) > 300) ok=true;
    }
    
    // 为敌人生成巡逻路径点（2~3个）——在其周围一定范围内、且不在墙内
    const waypoints = [];
    const wpCount = 2 + Math.floor(Math.random() * 2); // 2~3 个
    let wpAttempts = 0;
    while (waypoints.length < wpCount && wpAttempts < 40) {
        wpAttempts++;
        const ang = rand(0, Math.PI * 2);
        const distMin = 80, distMax = 200;
        const d = rand(distMin, distMax);
        const wx = ex + Math.cos(ang) * d;
        const wy = ey + Math.sin(ang) * d;
        // 确保在画布内且不在墙体中
        if (wx < 40 || wx > canvas.width - 40 || wy < 40 || wy > canvas.height - 40) continue;
        if (checkWall(wx, wy)) continue;
        waypoints.push({ x: wx, y: wy });
    }
    
    state.entities.enemies.push({
        id: Math.random().toString(36).substr(2,9),
        x: ex, y: ey, r: 16,
        freq: Math.floor(rand(CFG.freqMin, CFG.freqMax)),
        state: 'patrol', timer: 0, angle: rand(0, Math.PI*2),
        resCool: 0,
        lastPingTime: 0, pingType: null,
        targetX: null, targetY: null,
        searchTimer: 0,
        waypoints: waypoints,
        currentWPIndex: 0,
        uiElement: createAnalyzerUI()
    });
}

function spawnItem(type) {
    let ix, iy, ok=false;
    let safeLoop = 0;
    while(!ok && safeLoop < 100) {
        safeLoop++;
        ix = rand(50, canvas.width-50); iy = rand(50, canvas.height-50);
        
        // 检查是否在墙里
        if(checkWall(ix, iy)) continue;
        
        // 检查是否与instructions重叠（保持60像素距离）
        let overlapsInst = false;
        for (const inst of state.entities.instructions) {
            if (dist(ix, iy, inst.x, inst.y) < 60) {
                overlapsInst = true;
                break;
            }
        }
        
        if (!overlapsInst) ok = true;
    }
    if(ok) {
        state.entities.items.push({
            type: type, x: ix, y: iy, r: 10, visibleTimer: 0 // 默认不可见
        });
    }
}

function createAnalyzerUI() {
    const div = document.createElement('div');
    div.className = 'analyzer-tag';
    div.innerHTML = `<div style="text-align:center;margin-bottom:2px;">FREQ ANALYSIS</div><div class="analyzer-bar"><div class="analyzer-center"></div><div class="analyzer-pip" style="left:50%"></div></div><div class="analyzer-text" style="color:#aaa;">UNKNOWN</div>`;
    uiContainer.appendChild(div);
    return div;
}

// --- 输入处理 ---
window.onkeydown = e => {
    const k = e.key.toLowerCase();
    if(state.keys.hasOwnProperty(k) || k===' ') {
        state.keys[k===' '?'space':k] = true;
    }
    if(k==='e') tryInteract(); // E键通用交互
};
window.onkeyup = e => {
    const k = e.key.toLowerCase();
    if(state.keys.hasOwnProperty(k) || k===' ') {
        state.keys[k===' '?'space':k] = false;
        if(k===' ') releaseScan();
    }
};
canvas.onmousemove = e => { 
    const rect = canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;
    const worldPos = screenToWorld(canvasX, canvasY);
    state.mouse.x = worldPos.x; 
    state.mouse.y = worldPos.y; 
};
window.onwheel = e => {
    const d = Math.sign(e.deltaY) * -5;
    state.freq = clamp(state.freq+d, CFG.freqMin, CFG.freqMax);
    updateUI();
};

// --- 逻辑 ---
function updateFocus() {
    if(state.keys.space) {
        if(!state.isCharging) {
            state.isCharging = true;
            state.focusLevel = 0;
        }
        if(state.isCharging) {
            state.focusLevel = Math.min(1, state.focusLevel + 0.02);
        }
    }
}

function releaseScan() {
    if(!state.isCharging) return;
    
    // 计算当前角度（弧度）
    const currentSpread = lerp(CFG.maxSpread, CFG.minSpread, state.focusLevel);
    
    // 能量消耗公式（0~10）：频率越高、角度越聚焦，消耗越大
    const freqNorm = (state.freq - CFG.freqMin) / (CFG.freqMax - CFG.freqMin); // 0~1
    const focusNorm = clamp(1 - currentSpread / CFG.maxSpread, 0, 1);          // 0~1（360°=0，极窄≈1）
    const rawCost = 5 * freqNorm + 5 * focusNorm;                              // 理论范围约0~10
    const energyCost = clamp(Math.round(rawCost), 0, 10);
    
    // 检查能量是否足够（检查最大消耗长按能量）
    if(state.p.en < energyCost) {
        logMsg("LOW ENERGY - CANNOT EMIT");
        state.isCharging = false;
        state.focusLevel = 0;
        return;
    }

    state.p.en -= energyCost;
    
    emitWave(state.p.x, state.p.y, state.p.a, currentSpread, state.freq, 'player');
    
    state.isCharging = false; 
    state.focusLevel = 0; 
    updateUI();
}

function emitWave(x, y, angle, spread, freq, source, ownerId) {
    // 频率影响基础能量：低频(100Hz)=0.5x，中频(200Hz)=1x，高频(300Hz)=1.5x
    const freqFactor = 0.5 + (freq - CFG.freqMin) / (CFG.freqMax - CFG.freqMin);
    const baseEnergy = CFG.baseWaveEnergy * freqFactor;
    
    state.entities.waves.push({
        x: x, y: y, r: CFG.initialRadius, maxR: CFG.waveMaxDist,
        angle: angle, spread: spread, freq: freq, 
        baseEnergy: baseEnergy,      // 频率决定的基础能量
        source: source, ownerId: ownerId,
        isOriginalWave: (source === 'player' && spread < CFG.analyzeThreshold) // 标记是否是分析波纹（在创建时确定）
    });
}

// 增加能量（拾取或奖励）
function gainEnergy(amount) {
    let remaining = amount;
    
    // 1. 先填主能量
    const spaceInMain = CFG.maxEnergy - state.p.en;
    const toMain = Math.min(spaceInMain, remaining);
    state.p.en += toMain;
    remaining -= toMain;
    
    // 2. 溢出部分存入备用
    if (remaining > 0) {
        state.p.reserveEn += remaining;
    }
}

// 统一交互逻辑 (拾取 + 处决)
function tryInteract() {
    // 1. 优先尝试处决
    const enemies = state.entities.enemies.filter(e => e.state === 'stunned' && dist(e.x,e.y,state.p.x,state.p.y) < 60);
    if(enemies.length > 0) {
        const e = enemies[0];
        state.entities.enemies = state.entities.enemies.filter(x => x !== e);
        if(e.uiElement) e.uiElement.remove();
        
        // 根据共振类型给予不同奖励
        if (e.isPerfectStun) {
            // 完美共振：能量回满
            const energyGain = CFG.maxEnergy;
            gainEnergy(energyGain);
            logMsg("PERFECT SIPHON - FULL ENERGY RESTORED");
            spawnParticles(e.x, e.y, '#00ff00', 50); // 绿色粒子
        } else {
            // 普通共振：能量+50%
            const energyGain = CFG.maxEnergy * 0.5;
            gainEnergy(energyGain);
            logMsg(`CORE SIPHONED (+${Math.floor(energyGain)} ENERGY)`);
            spawnParticles(e.x, e.y, '#00ffff', 40); // 青色粒子
        }
        
        setTimeout(spawnEnemy, 4000);
        updateUI();
        return;
    }

    // 2. 尝试拾取
    const items = state.entities.items.filter(i => dist(i.x, i.y, state.p.x, state.p.y) < 40 && i.visibleTimer > 0);
    if(items.length > 0) {
        const item = items[0];
        if(item.type === 'energy') {
            gainEnergy(CFG.energyFlaskVal);
            logMsg(`ENERGY RESTORED (+${CFG.energyFlaskVal})`);
            spawnParticles(item.x, item.y, '#00ff00', 20);
            // 移除物品
            state.entities.items = state.entities.items.filter(i => i !== item);
            updateUI();
        }
        return;
    }
}

// 玩家治疗
function updateHeal() {
    if(state.keys.f && state.p.hp < CFG.maxHp && state.p.en >= CFG.healCost) {
        state.p.en -= CFG.healCost; state.p.hp = Math.min(CFG.maxHp, state.p.hp + CFG.healVal);
        state.keys.f = false; spawnParticles(state.p.x, state.p.y, '#00ff00', 15);
        logMsg("SYSTEM REPAIRED"); updateUI();
    }
}

// 使用备用能量补充主能量（R键）
function updateReserveEnergy() {
    if (state.keys.r && state.p.reserveEn > 0 && state.p.en < CFG.maxEnergy) {
        const needed = CFG.maxEnergy - state.p.en;
        const used = Math.min(needed, state.p.reserveEn);
        state.p.en += used;
        state.p.reserveEn -= used;
        state.keys.r = false;
        logMsg(`RESERVE TRANSFERRED (+${Math.floor(used)} ENERGY)`);
        spawnParticles(state.p.x, state.p.y, '#33ccff', 15);
        updateUI();
    }
}

// 更新相机位置（跟随玩家）
function updateCamera() {
    const targetX = state.p.x;
    const targetY = state.p.y;
    
    if (CFG.cameraSmoothing) {
        // 平滑跟随
        const dx = targetX - state.camera.x;
        const dy = targetY - state.camera.y;
        state.camera.x += dx * CFG.cameraFollowSpeed;
        state.camera.y += dy * CFG.cameraFollowSpeed;
    } else {
        // 直接跟随
        state.camera.x = targetX;
        state.camera.y = targetY;
    }
}

// 世界坐标转屏幕坐标（用于UI定位）
function worldToScreen(wx, wy) {
    const scale = CFG.cameraFOV;
    const screenX = (wx - state.camera.x) * scale + canvas.width / 2;
    const screenY = (wy - state.camera.y) * scale + canvas.height / 2;
    return { x: screenX, y: screenY };
}

// 屏幕坐标转世界坐标（用于鼠标交互）
function screenToWorld(sx, sy) {
    const scale = CFG.cameraFOV;
    const worldX = (sx - canvas.width / 2) / scale + state.camera.x;
    const worldY = (sy - canvas.height / 2) / scale + state.camera.y;
    return { x: worldX, y: worldY };
}

// ========== 更新函数拆分 ==========

// 更新玩家状态
function updatePlayer() {
    updateFocus(); 
    updateHeal();
    updateReserveEnergy();
    
    // 移动
    let dx=0, dy=0;
    if(state.keys.w) dy-=1; if(state.keys.s) dy+=1;
    if(state.keys.a) dx-=1; if(state.keys.d) dx+=1;
    if(dx||dy) {
        const len = Math.hypot(dx,dy);
        const spd = state.isCharging ? CFG.pSpeed * 0.3 : CFG.pSpeed;
        const nx = state.p.x + (dx/len)*spd; const ny = state.p.y + (dy/len)*spd;
        if(!checkWall(nx, state.p.y)) state.p.x = nx;
        if(!checkWall(state.p.x, ny)) state.p.y = ny;
    }
    
    // 角度跟随鼠标
    state.p.a = Math.atan2(state.mouse.y - state.p.y, state.mouse.x - state.p.x);
    
    // 冷却时间
    if(state.p.invuln > 0) state.p.invuln--;
    if(state.p.resCool > 0) state.p.resCool--;
}

// 更新物品可见性
function updateItemsVisibility() {
    state.entities.items.forEach(i => {
        if(i.visibleTimer > 0) i.visibleTimer--;
        if(isInCone(i.x, i.y) && checkLineOfSight(state.p.x, state.p.y, i.x, i.y)) {
            i.visibleTimer = 10; // 只要在视野里，就保持可见
        }
    });
}

// 处理波纹反弹（分割波纹）
function handleWaveBounce(w, wall, energyOnBounce, waveIndex) {
    // 记录墙壁轮廓（仅玩家波纹，避免重复添加）
    if (w.source === 'player') {
        const existingEcho = state.entities.wallEchoes.find(we => we.wall === wall);
        if (!existingEcho) {
            state.entities.wallEchoes.push({
                wall: wall,
                life: 1.0,
                energy: energyOnBounce
            });
        } else {
            existingEcho.life = Math.min(1.0, existingEcho.life + 0.3);
        }
    }
    
    // 计算被阻挡的角度范围
    const blockedRanges = getWaveBlockedAngles(w, wall);
    
    if (blockedRanges && blockedRanges.length > 0) {
        blockedRanges.sort((a, b) => a.start - b.start);
        
        const waveStartAngle = w.angle - w.spread / 2;
        const newWaves = [];
        let currentAngle = 0; // 相对于waveStartAngle的偏移
        
        for (const blockedRange of blockedRanges) {
            const rangeStart = Math.max(0, Math.min(blockedRange.start, w.spread));
            const rangeEnd = Math.max(0, Math.min(blockedRange.end, w.spread));
            
            // 添加被阻挡范围之前的部分
            if (rangeStart > currentAngle) {
                const remainingSpread = rangeStart - currentAngle;
                if (remainingSpread > 0.01) {
                    const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                    let normalizedAngle = newAngle;
                    while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                    while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                    
                    newWaves.push({
                        x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                        angle: normalizedAngle,
                        spread: remainingSpread,
                        freq: w.freq,
                        baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                        source: w.source,
                        ownerId: w.ownerId,
                        isOriginalWave: false // 分割后的片段不触发UI
                    });
                }
            }
            currentAngle = rangeEnd;
        }
        
        // 添加最后一个被阻挡范围之后的部分
        if (currentAngle < w.spread) {
            const remainingSpread = w.spread - currentAngle;
            if (remainingSpread > 0.01) {
                const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                let normalizedAngle = newAngle;
                while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                
                newWaves.push({
                    x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                    angle: normalizedAngle,
                    spread: remainingSpread,
                    freq: w.freq,
                    baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                    source: w.source,
                    ownerId: w.ownerId
                });
            }
        }
        
        // 添加新的波纹片段（原波纹会在updateWave中标记删除）
        for (const newWave of newWaves) {
            const isFullCircle = newWave.spread > Math.PI * 1.9;
            const circumference = isFullCircle ? (2 * Math.PI * newWave.r) : (newWave.r * newWave.spread);
            newWave.energyPerPoint = newWave.baseEnergy / (circumference > 0.01 ? circumference : 0.01);
            state.entities.waves.push(newWave);
        }
        
        return true; // 表示波纹已被分割/移除
    }
    return false; // 没有检测到被阻挡的角度
}

// 处理波纹穿透（分割波纹）
function handleWavePenetration(w, wall, waveIndex) {
    const penetrationLoss = 0.3; // 穿透损失30%能量
    
    // 计算被阻挡的角度范围（穿透的部分）
    const blockedRanges = getWaveBlockedAngles(w, wall);
    
    if (blockedRanges && blockedRanges.length > 0) {
        blockedRanges.sort((a, b) => a.start - b.start);
        
        const waveStartAngle = w.angle - w.spread / 2;
        const newWaves = [];
        let currentAngle = 0; // 相对于waveStartAngle的偏移
        
        for (const blockedRange of blockedRanges) {
            const rangeStart = Math.max(0, Math.min(blockedRange.start, w.spread));
            const rangeEnd = Math.max(0, Math.min(blockedRange.end, w.spread));
            
            // 添加被阻挡范围之前的部分（未穿透，不损失能量）
            if (rangeStart > currentAngle) {
                const remainingSpread = rangeStart - currentAngle;
                if (remainingSpread > 0.01) {
                    const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                    let normalizedAngle = newAngle;
                    while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                    while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                    
                    newWaves.push({
                        x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                        angle: normalizedAngle,
                        spread: remainingSpread,
                        freq: w.freq,
                        baseEnergy: w.baseEnergy * (remainingSpread / w.spread), // 不损失能量
                        source: w.source,
                        ownerId: w.ownerId,
                        isOriginalWave: false // 分割后的片段不触发UI
                    });
                }
            }
            
            // 添加被阻挡范围的部分（穿透，损失能量）
            const penetratedSpread = rangeEnd - rangeStart;
            if (penetratedSpread > 0.01) {
                const newAngle = waveStartAngle + rangeStart + penetratedSpread / 2;
                let normalizedAngle = newAngle;
                while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                
                newWaves.push({
                    x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                    angle: normalizedAngle,
                    spread: penetratedSpread,
                    freq: w.freq,
                    baseEnergy: w.baseEnergy * (penetratedSpread / w.spread) * (1 - penetrationLoss), // 损失30%能量
                    source: w.source,
                    ownerId: w.ownerId,
                    isOriginalWave: false // 分割后的片段不触发UI
                });
            }
            
            currentAngle = rangeEnd;
        }
        
        // 添加最后一个被阻挡范围之后的部分（未穿透，不损失能量）
        if (currentAngle < w.spread) {
            const remainingSpread = w.spread - currentAngle;
            if (remainingSpread > 0.01) {
                const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                let normalizedAngle = newAngle;
                while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                
                newWaves.push({
                    x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                    angle: normalizedAngle,
                    spread: remainingSpread,
                    freq: w.freq,
                    baseEnergy: w.baseEnergy * (remainingSpread / w.spread), // 不损失能量
                    source: w.source,
                    ownerId: w.ownerId
                });
            }
        }
        
        // 添加新的波纹片段（原波纹会在updateWave中标记删除）
        for (const newWave of newWaves) {
            const isFullCircle = newWave.spread > Math.PI * 1.9;
            const circumference = isFullCircle ? (2 * Math.PI * newWave.r) : (newWave.r * newWave.spread);
            newWave.energyPerPoint = newWave.baseEnergy / (circumference > 0.01 ? circumference : 0.01);
            state.entities.waves.push(newWave);
        }
        
        return true; // 表示波纹已被分割
    }
    return false; // 没有检测到被阻挡的角度
}

// 处理波纹与敌人的反弹（分割波纹）
function handleWaveEnemyBounce(w, enemy, energyOnBounce, waveIndex) {
    // 记录敌人轮廓（仅玩家波纹）
    if (w.source === 'player') {
        state.entities.echoes.push({
            x: enemy.x, y: enemy.y, r: enemy.r,
            type: 'enemy_bounce', // 新类型：敌人反弹回声
            life: 1.0,
            energy: energyOnBounce
        });
    }
    
    // 计算被阻挡的角度范围
    const blockedRanges = getWaveBlockedAnglesByCircle(w, enemy);
    
    if (blockedRanges && blockedRanges.length > 0) {
        blockedRanges.sort((a, b) => a.start - b.start);
        
        const waveStartAngle = w.angle - w.spread / 2;
        const newWaves = [];
        let currentAngle = 0;
        
        for (const blockedRange of blockedRanges) {
            const rangeStart = Math.max(0, Math.min(blockedRange.start, w.spread));
            const rangeEnd = Math.max(0, Math.min(blockedRange.end, w.spread));
            
            if (rangeStart > currentAngle) {
                const remainingSpread = rangeStart - currentAngle;
                if (remainingSpread > 0.01) {
                    const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                    let normalizedAngle = newAngle;
                    while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                    while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                    
                    newWaves.push({
                        x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                        angle: normalizedAngle,
                        spread: remainingSpread,
                        freq: w.freq,
                        baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                        source: w.source,
                        ownerId: w.ownerId,
                        isOriginalWave: false // 分割后的片段不触发UI
                    });
                }
            }
            currentAngle = rangeEnd;
        }
        
        if (currentAngle < w.spread) {
            const remainingSpread = w.spread - currentAngle;
            if (remainingSpread > 0.01) {
                const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                let normalizedAngle = newAngle;
                while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                
                newWaves.push({
                    x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                    angle: normalizedAngle,
                    spread: remainingSpread,
                    freq: w.freq,
                    baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                    source: w.source,
                    ownerId: w.ownerId
                });
            }
        }
        
        if (waveIndex !== undefined && waveIndex >= 0) {
            state.entities.waves.splice(waveIndex, 1);
        }
        
        for (const newWave of newWaves) {
            const isFullCircle = newWave.spread > Math.PI * 1.9;
            const circumference = isFullCircle ? (2 * Math.PI * newWave.r) : (newWave.r * newWave.spread);
            newWave.energyPerPoint = newWave.baseEnergy / (circumference > 0.01 ? circumference : 0.01);
            state.entities.waves.push(newWave);
        }
        
        return true;
    }
    return false;
}

// 处理波纹与敌人的穿透（分割波纹）
function handleWaveEnemyPenetration(w, enemy, waveIndex) {
    const penetrationLoss = 0.3; // 穿透损失30%能量
    
    // 计算被阻挡的角度范围（穿透的部分）
    const blockedRanges = getWaveBlockedAnglesByCircle(w, enemy);
    
    if (blockedRanges && blockedRanges.length > 0) {
        blockedRanges.sort((a, b) => a.start - b.start);
        
        const waveStartAngle = w.angle - w.spread / 2;
        const newWaves = [];
        let currentAngle = 0;
        
        for (const blockedRange of blockedRanges) {
            const rangeStart = Math.max(0, Math.min(blockedRange.start, w.spread));
            const rangeEnd = Math.max(0, Math.min(blockedRange.end, w.spread));
            
            // 未穿透部分：不损失能量
            if (rangeStart > currentAngle) {
                const remainingSpread = rangeStart - currentAngle;
                if (remainingSpread > 0.01) {
                    const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                    let normalizedAngle = newAngle;
                    while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                    while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                    
                    newWaves.push({
                        x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                        angle: normalizedAngle,
                        spread: remainingSpread,
                        freq: w.freq,
                        baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                        source: w.source,
                        ownerId: w.ownerId,
                        isOriginalWave: false // 分割后的片段不触发UI
                    });
                }
            }
            
            // 穿透部分：损失30%能量
            const penetratedSpread = rangeEnd - rangeStart;
            if (penetratedSpread > 0.01) {
                const newAngle = waveStartAngle + rangeStart + penetratedSpread / 2;
                let normalizedAngle = newAngle;
                while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                
                newWaves.push({
                    x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                    angle: normalizedAngle,
                    spread: penetratedSpread,
                    freq: w.freq,
                    baseEnergy: w.baseEnergy * (penetratedSpread / w.spread) * (1 - penetrationLoss),
                    source: w.source,
                    ownerId: w.ownerId,
                    isOriginalWave: false // 分割后的片段不触发UI
                });
            }
            
            currentAngle = rangeEnd;
        }
        
        if (currentAngle < w.spread) {
            const remainingSpread = w.spread - currentAngle;
            if (remainingSpread > 0.01) {
                const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                let normalizedAngle = newAngle;
                while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                
                newWaves.push({
                    x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                    angle: normalizedAngle,
                    spread: remainingSpread,
                    freq: w.freq,
                    baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                    source: w.source,
                    ownerId: w.ownerId
                });
            }
        }
        
        if (waveIndex !== undefined && waveIndex >= 0) {
            state.entities.waves.splice(waveIndex, 1);
        }
        
        for (const newWave of newWaves) {
            const isFullCircle = newWave.spread > Math.PI * 1.9;
            const circumference = isFullCircle ? (2 * Math.PI * newWave.r) : (newWave.r * newWave.spread);
            newWave.energyPerPoint = newWave.baseEnergy / (circumference > 0.01 ? circumference : 0.01);
            state.entities.waves.push(newWave);
        }
        
        return true;
    }
    return false;
}

// 处理波纹与玩家的反弹（分割波纹）
function handleWavePlayerBounce(w, energyOnBounce, waveIndex) {
    const player = { x: state.p.x, y: state.p.y, r: CFG.playerRadius };
    const blockedRanges = getWaveBlockedAnglesByCircle(w, player);
    
    // 记录玩家轮廓回声（仅非玩家波纹）
    if (w.source !== 'player') {
        state.entities.echoes.push({
            x: player.x, y: player.y, r: player.r,
            type: 'player_bounce',
            life: 1.0,
            energy: energyOnBounce
        });
    }
    
    if (blockedRanges && blockedRanges.length > 0) {
        blockedRanges.sort((a, b) => a.start - b.start);
        
        const waveStartAngle = w.angle - w.spread / 2;
        const newWaves = [];
        let currentAngle = 0;
        
        for (const blockedRange of blockedRanges) {
            const rangeStart = Math.max(0, Math.min(blockedRange.start, w.spread));
            const rangeEnd = Math.max(0, Math.min(blockedRange.end, w.spread));
            
            if (rangeStart > currentAngle) {
                const remainingSpread = rangeStart - currentAngle;
                if (remainingSpread > 0.01) {
                    const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                    let normalizedAngle = newAngle;
                    while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                    while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                    
                    newWaves.push({
                        x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                        angle: normalizedAngle,
                        spread: remainingSpread,
                        freq: w.freq,
                        baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                        source: w.source,
                        ownerId: w.ownerId,
                        isOriginalWave: false
                    });
                }
            }
            currentAngle = rangeEnd;
        }
        
        if (currentAngle < w.spread) {
            const remainingSpread = w.spread - currentAngle;
            if (remainingSpread > 0.01) {
                const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                let normalizedAngle = newAngle;
                while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                
                newWaves.push({
                    x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                    angle: normalizedAngle,
                    spread: remainingSpread,
                    freq: w.freq,
                    baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                    source: w.source,
                    ownerId: w.ownerId
                });
            }
        }
        
        if (waveIndex !== undefined && waveIndex >= 0) {
            state.entities.waves.splice(waveIndex, 1);
        }
        
        for (const newWave of newWaves) {
            const isFullCircle = newWave.spread > Math.PI * 1.9;
            const circumference = isFullCircle ? (2 * Math.PI * newWave.r) : (newWave.r * newWave.spread);
            newWave.energyPerPoint = newWave.baseEnergy / (circumference > 0.01 ? circumference : 0.01);
            state.entities.waves.push(newWave);
        }
        
        return true;
    }
    return false;
}

// 处理波纹与玩家的穿透（分割波纹）
function handleWavePlayerPenetration(w, waveIndex) {
    const penetrationLoss = 0.3;
    const player = { x: state.p.x, y: state.p.y, r: CFG.playerRadius };
    
    const blockedRanges = getWaveBlockedAnglesByCircle(w, player);
    if (blockedRanges && blockedRanges.length > 0) {
        blockedRanges.sort((a, b) => a.start - b.start);
        
        const waveStartAngle = w.angle - w.spread / 2;
        const newWaves = [];
        let currentAngle = 0;
        
        for (const blockedRange of blockedRanges) {
            const rangeStart = Math.max(0, Math.min(blockedRange.start, w.spread));
            const rangeEnd = Math.max(0, Math.min(blockedRange.end, w.spread));
            
            // 未穿透部分：不损失能量
            if (rangeStart > currentAngle) {
                const remainingSpread = rangeStart - currentAngle;
                if (remainingSpread > 0.01) {
                    const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                    let normalizedAngle = newAngle;
                    while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                    while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                    
                    newWaves.push({
                        x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                        angle: normalizedAngle,
                        spread: remainingSpread,
                        freq: w.freq,
                        baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                        source: w.source,
                        ownerId: w.ownerId,
                        isOriginalWave: false
                    });
                }
            }
            
            // 穿透玩家的部分：损失能量
            const penetratedSpread = rangeEnd - rangeStart;
            if (penetratedSpread > 0.01) {
                const newAngle = waveStartAngle + rangeStart + penetratedSpread / 2;
                let normalizedAngle = newAngle;
                while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                
                newWaves.push({
                    x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                    angle: normalizedAngle,
                    spread: penetratedSpread,
                    freq: w.freq,
                    baseEnergy: w.baseEnergy * (penetratedSpread / w.spread) * (1 - penetrationLoss),
                    source: w.source,
                    ownerId: w.ownerId,
                    isOriginalWave: false
                });
            }
            
            currentAngle = rangeEnd;
        }
        
        if (currentAngle < w.spread) {
            const remainingSpread = w.spread - currentAngle;
            if (remainingSpread > 0.01) {
                const newAngle = waveStartAngle + currentAngle + remainingSpread / 2;
                let normalizedAngle = newAngle;
                while (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                while (normalizedAngle >= Math.PI * 2) normalizedAngle -= Math.PI * 2;
                
                newWaves.push({
                    x: w.x, y: w.y, r: w.r, maxR: w.maxR,
                    angle: normalizedAngle,
                    spread: remainingSpread,
                    freq: w.freq,
                    baseEnergy: w.baseEnergy * (remainingSpread / w.spread),
                    source: w.source,
                    ownerId: w.ownerId
                });
            }
        }
        
        if (waveIndex !== undefined && waveIndex >= 0) {
            state.entities.waves.splice(waveIndex, 1);
        }
        
        for (const newWave of newWaves) {
            const isFullCircle = newWave.spread > Math.PI * 1.9;
            const circumference = isFullCircle ? (2 * Math.PI * newWave.r) : (newWave.r * newWave.spread);
            newWave.energyPerPoint = newWave.baseEnergy / (circumference > 0.01 ? circumference : 0.01);
            state.entities.waves.push(newWave);
        }
        
        // 在玩家身上留下穿透回声（轻微）
        // if (w.source !== 'player') {
        //     state.entities.echoes.push({
        //         x: player.x, y: player.y, r: player.r,
        //         type: 'player_resonance',
        //         life: 0.6
        //     });
        // }
        
        return true;
    }
    return false;
}

// 敌人波纹击中玩家的统一处理（物理 / 共振 / AI / 波形反馈）
function handleWavePlayerInteraction(w, oldR, waveIndex) {
    // 忽略玩家自己的波纹
    if (w.source === 'player') return 'none';
    
    const dToP = dist(state.p.x, state.p.y, w.x, w.y);
    // 使用 oldR / w.r 判断扩散环本帧是否扫过玩家
    if (dToP < oldR || dToP > w.r) return 'none';
    
    // 角度检查：玩家必须在扇形范围内，或波近似全向
    const angleToP = Math.atan2(state.p.y - w.y, state.p.x - w.x);
    let angleDiff = Math.abs(angleToP - w.angle);
    while (angleDiff > Math.PI) angleDiff = Math.abs(angleDiff - Math.PI * 2);
    if (!(w.spread > Math.PI || angleDiff < w.spread / 2)) return 'none';
    
    // 物理与共振判定
    const playerFreq = state.freq;
    const freqDelta = Math.abs(w.freq - playerFreq);
    const isPerfectResonance = freqDelta <= CFG.perfectResTol;
    const isNormalResonance = freqDelta <= CFG.normalResTol;
    const willBounce = w.freq > playerFreq;
    
    // AI 感知层：仅在反弹或发生共振时，敌人记住玩家坐标
    if ((willBounce || isNormalResonance) && w.ownerId) {
        const enemy = state.entities.enemies.find(e => e.id === w.ownerId);
        if (enemy && enemy.state !== 'stunned') {
            onEnemySensesPlayer(enemy, state.p.x, state.p.y);
            logMsg("HOSTILE LOCKED ON");
            spawnParticles(state.p.x, state.p.y, '#00ffff', 12);
        }
    }
    
    // 伤害 / 过载与受迫共振：只在发生共振且冷却就绪时触发
    if (isNormalResonance && state.p.resCool <= 0) {
        // 估算击中玩家的总能量
        const playerDiameter = CFG.playerRadius * 2;
        const maxArcLength = w.r * (w.spread > 0.001 ? w.spread : 0.001);
        const coveredArcLength = Math.min(playerDiameter, maxArcLength);
        const totalEnergyOnPlayer = w.energyPerPoint * coveredArcLength;
        
        let energyCost = CFG.forcedWaveCost;
        let damage = 0;
        
        // 能量不足时，造成过载伤害
        if (state.p.en < energyCost) {
            damage = (energyCost - state.p.en) * CFG.overloadDmgRatio;
            state.p.en = 0;
            takeDamage(damage);
            logMsg(`CRITICAL OVERLOAD (-${Math.floor(damage)} HP)`);
        } else {
            state.p.en -= energyCost;
            logMsg("SYSTEM OVERLOAD: ENERGY DRAIN");
        }
        
        // 高能量密度下的额外过载惩罚
        const overloadThreshold = CFG.baseWaveEnergy * CFG.energyThreshold;
        if (totalEnergyOnPlayer >= overloadThreshold) {
            // 若之前未造成HP伤害，则再追加一次受损
            if (damage === 0) {
                takeDamage(CFG.dmgVal);
            }
            flashScreen('#00ffff', 150);
        } else {
            flashScreen('#00ffff', 100);
        }
        
        // 玩家被迫发出自发波（与敌人受迫共振对称）
        emitWave(state.p.x, state.p.y, 0, Math.PI * 2, state.freq, 'player');
        state.p.resCool = CFG.resCooldown;
        updateUI();
    }
    
    // 波形反馈：根据“硬度”决定反弹或穿透的几何行为
    if (willBounce) {
        const energyOnBounce = w.energyPerPoint;
        const handled = handleWavePlayerBounce(w, energyOnBounce, waveIndex);
        return handled ? 'bounced' : 'none';
    } else {
        const handled = handleWavePlayerPenetration(w, waveIndex);
        return handled ? 'penetrated' : 'none';
    }
}

// 处理波纹与墙壁的碰撞
function handleWaveWallCollision(w, oldR, waveIndex) {
    for (let wall of state.entities.walls) {
        const collision = checkWaveWallCollision(w, wall);
        if (collision.hit) {
            const distToWall = collision.dist;
            if (distToWall >= oldR - CFG.waveSpeed && distToWall <= w.r + CFG.waveSpeed) {
                if (w.freq > wall.blockFreq) {
                    // 反弹
                    const energyOnBounce = w.energyPerPoint;
                    const wasHandled = handleWaveBounce(w, wall, energyOnBounce, waveIndex);
                    return wasHandled ? 'bounced' : 'removed';
                } else {
                    // 穿透
                    const wasHandled = handleWavePenetration(w, wall, waveIndex);
                    if (wasHandled) {
                        return 'penetrated'; // 表示波纹已被分割
                    }
                }
            }
        }
    }
    return 'none';
}

// 检查波纹与物品的碰撞
function checkWaveItemCollisions(w) {
    state.entities.items.forEach(item => {
        const d = dist(item.x, item.y, w.x, w.y);
        if(Math.abs(d - w.r) < CFG.waveSpeed) {
            item.visibleTimer = 120; // 可见2秒
            state.entities.echoes.push({
                x: item.x, y: item.y, r: 2, type: 'item', life: 1.0
            });
        }
    });
}

// 处理波纹与敌人碰撞（分割波纹）
function handleWaveEnemyCollision(w, oldR, waveIndex) {
    for (let enemy of state.entities.enemies) {
        if(w.ownerId === enemy.id) continue;
        
        const d = dist(enemy.x, enemy.y, w.x, w.y);
        // 使用上一帧半径 oldR 和当前半径 w.r，判断扩散环是否“扫过”敌人
        if(d >= oldR && d <= w.r) {
            const angleToE = Math.atan2(enemy.y - w.y, enemy.x - w.x);
            let angleDiff = Math.abs(angleToE - w.angle);
            while(angleDiff > Math.PI) angleDiff = Math.abs(angleDiff - Math.PI*2);
            
            if(w.spread > Math.PI || angleDiff < w.spread/2) {
                // 计算打到敌人的总能量
                const enemyDiameter = 2 * enemy.r;
                const maxArcLength = w.r * w.spread;
                const coveredArcLength = Math.min(enemyDiameter, maxArcLength);
                const totalEnergy = w.energyPerPoint * coveredArcLength;
                
                // 检测共振
                const freqDelta = Math.abs(w.freq - enemy.freq);
                const isPerfectResonance = freqDelta <= CFG.perfectResTol;
                const isNormalResonance = freqDelta <= CFG.normalResTol;
                
                // 判断是穿透还是反弹
                const willBounce = w.freq > enemy.freq;
                
                // 根据能量决定信息等级
                const isLongDuration = totalEnergy >= CFG.infoLevelLong;
                const showAnalyzeUI = totalEnergy >= CFG.infoLevelAnalyze;
                const isClearOutline = totalEnergy >= CFG.infoLevelClear;
                
                // 玩家波纹才显示信息
                if (w.source === 'player') {
                    if (willBounce) {
                        // 反弹：根据能量显示清晰轮廓或分析UI
                        if (showAnalyzeUI) {
                            // 高能量：显示分析UI
                            state.entities.echoes.push({
                                x: enemy.x, y: enemy.y, r: enemy.r, 
                                type: 'analyze',
                                life: isLongDuration ? 5.0 : 2.0,
                                enemyId: enemy.id,
                                isResonance: isNormalResonance,
                                isPerfect: isPerfectResonance
                            });
                            enemy.lastPingTime = Date.now();
                            enemy.pingType = 'analyze';
                        } else {
                            // 中低能量：显示清晰轮廓
                            state.entities.echoes.push({
                                x: enemy.x, y: enemy.y, r: enemy.r,
                                type: 'enemy_bounce',
                                life: isClearOutline ? 1.0 : 0.5
                            });
                        }
                    } else {
                        // 穿透：显示模糊轮廓（短暂）
                        if (showAnalyzeUI) {
                            // 高能量穿透（低频聚焦）：短暂分析UI
                            state.entities.echoes.push({
                                x: enemy.x, y: enemy.y, r: enemy.r, 
                                type: 'analyze',
                                life: isLongDuration ? 2.0 : 1.0,
                                enemyId: enemy.id,
                                isResonance: isNormalResonance,
                                isPerfect: isPerfectResonance
                            });
                            enemy.lastPingTime = Date.now();
                            enemy.pingType = 'analyze';
                        } else {
                            // 低能量穿透：模糊轮廓
                            state.entities.echoes.push({
                                x: enemy.x, y: enemy.y, r: enemy.r,
                                type: 'enemy_blur',  // 新类型：模糊轮廓
                                life: 0.3
                            });
                        }
                    }
                }
                
                // 触发共振效果
                if (isNormalResonance && enemy.resCool <= 0) {
                    // 记录共振轮廓回声（绿色）
                    state.entities.echoes.push({
                        x: enemy.x, y: enemy.y, r: enemy.r,
                        type: 'enemy_resonance',
                        life: 1.0,
                        isPerfect: isPerfectResonance
                    });
                    
                    // 共振反应：被击中的敌人发射环形波纹
                    emitWave(enemy.x, enemy.y, 0, Math.PI*2, enemy.freq, 'enemy', enemy.id);
                    enemy.resCool = CFG.resCooldown;
                    
                    // 敌人会警觉并追踪波纹来源位置
                    if (enemy.state === 'idle' || enemy.state === 'alert' || enemy.state === 'patrol' || enemy.state === 'searching') {
                        onEnemySensesPlayer(enemy, w.x, w.y);
                    }
                    
                    // 过载效果：基于能量阈值判断
                    const minCircumference = CFG.initialRadius * CFG.minSpread;
                    const minEnergyPerPoint = CFG.baseWaveEnergy / minCircumference;
                    const standardEnemyR = 16;
                    const standardEnemyAngleSpan = 2 * Math.asin(Math.min(1.0, standardEnemyR / CFG.initialRadius));
                    const standardCoveredArcLength = CFG.initialRadius * Math.min(standardEnemyAngleSpan, CFG.minSpread);
                    const minTotalEnergy = minEnergyPerPoint * standardCoveredArcLength;
                    const overloadThreshold = minTotalEnergy * 0.1;
                    
                    if (totalEnergy >= overloadThreshold) {
                        enemy.state = 'stunned';
                        enemy.isPerfectStun = isPerfectResonance; // 标记是否完美共振
                        enemy.timer = isPerfectResonance ? (CFG.stunTime * 1.5) : CFG.stunTime;
                        enemy.stunWaveCooldown = 0; // 用于完美共振持续发波
                        
                        if (isPerfectResonance) {
                            logMsg("PERFECT RESONANCE - TARGET DESTABILIZING");
                        } else {
                            logMsg("TARGET STABILIZED");
                        }
                    }
                }
                
                // 非共振时的警报逻辑（高能量波纹会触发警报）
                if (!isNormalResonance && w.source === 'player' && showAnalyzeUI) {
                    if (enemy.state !== 'stunned') {
                        onEnemySensesPlayer(enemy, state.p.x, state.p.y);
                        logMsg("HOSTILE ALERTED (HIGH ENERGY BEAM)");
                    }
                }
                
                // 然后判断穿透或反弹（使用敌人的freq作为blockFreq）
                if (willBounce) {
                    // 反弹
                    const energyOnBounce = w.energyPerPoint;
                    const wasHandled = handleWaveEnemyBounce(w, enemy, energyOnBounce, waveIndex);
                    return wasHandled ? 'bounced' : 'none';
                } else {
                    // 穿透
                    const wasHandled = handleWaveEnemyPenetration(w, enemy, waveIndex);
                    if (wasHandled) {
                        return 'penetrated';
                    }
                }
            }
        }
    }
    return 'none';
}

// 敌人感知到玩家位置（统一触发入口）
function onEnemySensesPlayer(enemy, playerX, playerY) {
    if (!enemy || enemy.state === 'stunned') return;
    enemy.state = 'alert';
    enemy.targetX = playerX;
    enemy.targetY = playerY;
    enemy.searchTimer = 0;
}

// 更新单个波纹
function updateWave(w, i) {
    const oldR = w.r;
    w.r += CFG.waveSpeed;
    
    // 能量稀释
    const isFullCircle = w.spread > Math.PI * 1.9;
    const circumference = isFullCircle ? (2 * Math.PI * w.r) : (w.r * w.spread);
    w.energyPerPoint = w.baseEnergy / (circumference > 0.01 ? circumference : 0.01);
    
    // 检查是否超出范围或能量耗尽
    if(w.r > w.maxR || w.energyPerPoint <= 0) {
        w._toRemove = true;
        return;
    }
    
    // 先检测与敌人的碰撞（分割波纹）
    const enemyCollisionResult = handleWaveEnemyCollision(w, oldR, i);
    if (enemyCollisionResult === 'bounced' || enemyCollisionResult === 'penetrated') {
        // 波纹已被分割，标记删除
        w._toRemove = true;
        return;
    }
    
    // 检测与玩家的交互（物理 / 共振 / AI / 分割）
    const playerCollisionResult = handleWavePlayerInteraction(w, oldR, i);
    if (playerCollisionResult === 'bounced' || playerCollisionResult === 'penetrated') {
        w._toRemove = true;
        return;
    }
    
    // 检测与墙壁的碰撞
    const wallCollisionResult = handleWaveWallCollision(w, oldR, i);
    if (wallCollisionResult === 'bounced' || wallCollisionResult === 'penetrated') {
        w._toRemove = true;
        return;
    }
    
    // 检查与物品的交互（不分割波纹）
    checkWaveItemCollisions(w);
}

// 更新敌人UI
function updateEnemyUI(e) {
    const ui = e.uiElement;
    if (Date.now() - e.lastPingTime < 2000 && e.pingType === 'analyze') {
        const screenPos = worldToScreen(e.x, e.y - 20);
        ui.style.display = 'block'; 
        ui.style.left = screenPos.x + 'px'; 
        ui.style.top = screenPos.y + 'px';
        
        let diff = clamp((e.freq - state.freq) / 100, -1, 1);
        const offset = 40 + (diff * 38);
        ui.querySelector('.analyzer-pip').style.left = offset + 'px';
        
        const text = ui.querySelector('.analyzer-text');
        const pip = ui.querySelector('.analyzer-pip');
        const freqDiff = Math.abs(state.freq - e.freq);
        
        if(freqDiff <= CFG.perfectResTol) {
            // 完美共振：亮绿色
            pip.style.backgroundColor = '#00ff00';
            text.innerHTML = "<span style='color:#00ff00'>[◆ PERFECT RESONANCE]</span>";
        } else if(freqDiff <= CFG.normalResTol) {
            // 普通共振：浅绿色
            pip.style.backgroundColor = '#88ff88';
            text.innerHTML = "<span style='color:#88ff88'>[● RESONANCE]</span>";
        } else if(diff < 0) {
            pip.style.backgroundColor = '#0088ff';
            text.innerHTML = "<span style='color:#0088ff'>▼ BLUE SHIFT</span>"; 
        } else {
            pip.style.backgroundColor = '#ff4400';
            text.innerHTML = "<span style='color:#ff4400'>▲ RED SHIFT</span>";
        }
    } else {
        ui.style.display = 'none';
    }
}

// 更新敌人移动
function updateEnemyMovement(e) {
    // STUNNED 状态在 updateEnemies 中处理，这里直接返回
    if (e.state === 'stunned') return;
    
    // 搜寻状态：原地停顿并在中途发出搜索波
    if (e.state === 'searching') {
        if (e.searchTimer == null || e.searchTimer <= 0) {
            e.searchTimer = 60;
        }
        e.searchTimer--;
        
        if (e.searchTimer === 30) {
            // 主动搜索波
            emitWave(e.x, e.y, 0, Math.PI * 2, e.freq, 'enemy', e.id);
            // 视觉 Ping：强调“正在搜索”
            state.entities.echoes.push({
                x: e.x, y: e.y, r: e.r * 2,
                type: 'enemy_search_ping',
                life: 0.8
            });
        }
        
        if (e.searchTimer <= 0) {
            e.state = 'patrol';
        }
        return;
    }
    
    let spd = CFG.eSpeedPatrol;
    let tx = null, ty = null;
    
    if (e.state === 'alert') {
        spd = CFG.eSpeedChase;
        tx = (e.targetX != null ? e.targetX : state.p.x);
        ty = (e.targetY != null ? e.targetY : state.p.y);
        
        const distToTarget = dist(e.x, e.y, tx, ty);
        if (distToTarget < 10) {
            // 到达最后已知位置，若仍未击中玩家，则进入搜寻阶段
            e.state = 'searching';
            e.searchTimer = 60;
            return;
        }
    } else if (e.state === 'patrol') {
        // 巡逻：沿 waypoints 循环
        if (e.waypoints && e.waypoints.length > 0) {
            const idx = e.currentWPIndex || 0;
            const wp = e.waypoints[idx];
            tx = wp.x;
            ty = wp.y;
            
            const distToWP = dist(e.x, e.y, tx, ty);
            if (distToWP < 5) {
                e.currentWPIndex = (idx + 1) % e.waypoints.length;
            }
        } else {
            // 没有路径点则使用原来的随机游走行为
            if (Math.random() < 0.01) {
                e.angle += (Math.random() - 0.5);
            }
        }
    } else {
        // 其他未知状态：退化为轻微游走
        if (Math.random() < 0.01) {
            e.angle += (Math.random() - 0.5);
        }
    }
    
    if (tx != null && ty != null) {
        let angleToTarget = Math.atan2(ty - e.y, tx - e.x);
        
        // 避障逻辑
        const lookAheadDist = 40;
        let avoidX = 0, avoidY = 0;
        let hasObs = false;
        
        const checkAngles = [0, -0.5, 0.5];
        for (let da of checkAngles) {
            const checkA = e.angle + da;
            const cx = e.x + Math.cos(checkA) * lookAheadDist;
            const cy = e.y + Math.sin(checkA) * lookAheadDist;
            if (checkWall(cx, cy)) {
                hasObs = true;
                avoidX -= Math.cos(checkA) * 2.0;
                avoidY -= Math.sin(checkA) * 2.0;
            }
        }
        
        if (hasObs) {
            const targetDx = Math.cos(angleToTarget);
            const targetDy = Math.sin(angleToTarget);
            const finalDx = targetDx + avoidX * 2.0;
            const finalDy = targetDy + avoidY * 2.0;
            e.angle = Math.atan2(finalDy, finalDx);
        } else {
            e.angle = angleToTarget;
        }
    }
    
    const mx = Math.cos(e.angle) * spd;
    const my = Math.sin(e.angle) * spd;
    if (!checkWall(e.x + mx, e.y + my)) {
        e.x += mx;
        e.y += my;
    } else {
        e.angle += (Math.random() > 0.5 ? 1 : -1) * Math.PI / 2;
    }
}

// 更新敌人
function updateEnemies() {
    let hasExeTarget = false;
    const enemiesToRemove = []; // 需要移除的敌人（完美共振死亡）
    
    state.entities.enemies.forEach(e => {
        if(e.resCool > 0) e.resCool--;
        
        updateEnemyUI(e);
        
        const dToP = dist(e.x, e.y, state.p.x, state.p.y);
        
        if(e.state === 'stunned') {
            e.timer--;
            
            // 完美共振：持续发出受迫共振波
            if (e.isPerfectStun) {
                if (e.stunWaveCooldown <= 0) {
                    emitWave(e.x, e.y, 0, Math.PI * 2, e.freq, 'enemy', e.id);
                    e.stunWaveCooldown = 60; // 每60帧（约1秒）发一次波
                    spawnParticles(e.x, e.y, '#ff4400', 15); // 红色粒子表示危险
                } else {
                    e.stunWaveCooldown--;
                }
            }
            
            if(e.timer <= 0) {
                if (e.isPerfectStun) {
                    // 完美共振结束后：敌人死亡
                    enemiesToRemove.push(e);
                    spawnParticles(e.x, e.y, '#00ffff', 50);
                    logMsg("HOSTILE DISINTEGRATED");
                    setTimeout(spawnEnemy, 5000); // 5秒后重生新敌人
                } else {
                    // 普通共振结束后：恢复正常
                    e.state = 'alert';
                    e.isPerfectStun = false;
                }
            }
            
            if(dToP < 60) hasExeTarget = true;
        } else {
            if(dToP < 25) takeDamage(CFG.dmgVal);
            updateEnemyMovement(e);
        }
    });
    
    // 移除完美共振死亡的敌人
    enemiesToRemove.forEach(e => {
        state.entities.enemies = state.entities.enemies.filter(x => x !== e);
        if(e.uiElement) e.uiElement.remove();
    });
    
    return hasExeTarget;
}

// 检查拾取物
function checkPickups() {
    let hasPickupTarget = false;
    state.entities.items.forEach(i => {
        if(i.visibleTimer > 0 && dist(i.x, i.y, state.p.x, state.p.y) < 40) {
            hasPickupTarget = true;
        }
    });
    return hasPickupTarget;
}

// 更新交互提示
function updateInteractionHints(hasExeTarget, hasPickupTarget) {
    if(hasExeTarget) {
        const screenPos = worldToScreen(state.p.x, state.p.y - 40);
        executeHint.style.display = 'block';
        executeHint.style.left = screenPos.x + 'px';
        executeHint.style.top = screenPos.y + 'px';
        pickupHint.style.display = 'none';
    } else if(hasPickupTarget) {
        const screenPos = worldToScreen(state.p.x, state.p.y - 40);
        executeHint.style.display = 'none';
        pickupHint.style.display = 'block';
        pickupHint.style.left = screenPos.x + 'px';
        pickupHint.style.top = screenPos.y + 'px';
    } else {
        executeHint.style.display = 'none';
        pickupHint.style.display = 'none';
    }
}

// 更新粒子和回声
function updateParticlesAndEchoes() {
    state.entities.particles.forEach(p => {
        p.x += p.vx; 
        p.y += p.vy; 
        p.life -= 0.05;
    });
    state.entities.particles = state.entities.particles.filter(p=>p.life>0);
    
    state.entities.echoes.forEach(e => e.life -= 0.015);
    state.entities.echoes = state.entities.echoes.filter(e => e.life>0);
    
    state.entities.wallEchoes.forEach(we => we.life -= 0.02);
    state.entities.wallEchoes = state.entities.wallEchoes.filter(we => we.life>0);
}

// 主更新函数
function update() {
    updatePlayer();
    updateCamera();
    updateItemsVisibility();

    // 更新波纹（标记-清理模式避免重叠）
    // 第一遍：更新所有波纹，标记需要删除的
    for(let i = 0; i < state.entities.waves.length; i++) {
        updateWave(state.entities.waves[i], i);
    }
    // 第二遍：清理标记为删除的波纹
    state.entities.waves = state.entities.waves.filter(w => !w._toRemove);
    
    // 更新敌人和检查交互
    const hasExeTarget = updateEnemies();
    const hasPickupTarget = checkPickups();
    updateInteractionHints(hasExeTarget, hasPickupTarget);
    
    updateParticlesAndEchoes();
    updateUI();
}

// --- 渲染 ---
function draw() {
    ctx.fillStyle = '#000510';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 应用相机变换
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(CFG.cameraFOV, CFG.cameraFOV);
    ctx.translate(-state.camera.x, -state.camera.y);

    // 绘制回声
    state.entities.echoes.forEach(e => {
        ctx.globalAlpha = e.life;
        
        if(e.type === 'item') {
            // 物品：绿色
            ctx.fillStyle = '#00ff00';
            ctx.beginPath(); ctx.arc(e.x, e.y, 5, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#00ff00'; ctx.lineWidth=1; ctx.stroke();
        } else if(e.type === 'analyze') {
            // 分析回声：完美共振亮绿色，普通共振浅绿色，否则白色
            let color = '#ffffff';
            if (e.isPerfect) {
                color = '#00ff00'; // 完美共振：亮绿色
            } else if (e.isResonance) {
                color = '#88ff88'; // 普通共振：浅绿色
            }
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath(); 
            ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); 
            ctx.stroke();
            ctx.fillStyle = color; 
            ctx.beginPath(); 
            ctx.arc(e.x, e.y, 4, 0, Math.PI*2); 
            ctx.fill();
        } else if(e.type === 'enemy_bounce') {
            // 敌人反弹回声：白色清晰轮廓
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath(); 
            ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); 
            ctx.stroke();
        } else if(e.type === 'enemy_blur') {
            // 敌人穿透回声：灰色模糊轮廓
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); // 虚线
            ctx.beginPath(); 
            ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); 
            ctx.stroke();
            ctx.setLineDash([]); // 恢复实线
        } else if(e.type === 'enemy_resonance') {
            // 敌人共振回声：绿色轮廓（完美共振更亮）
            const color = e.isPerfect ? '#00ff00' : '#88ff88';
            ctx.strokeStyle = color;
            ctx.lineWidth = 3; // 比反弹轮廓稍粗
            ctx.beginPath(); 
            ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); 
            ctx.stroke();
        } else if(e.type === 'enemy_search_ping') {
            // 敌人主动搜索 Ping：橙色粗环
            ctx.strokeStyle = '#ff9900';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r * (1 + (1 - e.life) * 0.5), 0, Math.PI * 2);
            ctx.stroke();
        } else if(e.type === 'player_bounce') {
            // 玩家作为硬墙反弹：亮青色轮廓
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
            ctx.stroke();
        } else if(e.type === 'player_resonance') {
            // 玩家被高能共振命中：青绿混色轮廓
            ctx.strokeStyle = '#33ffcc';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r * (1 + (1 - e.life) * 0.2), 0, Math.PI * 2);
            ctx.stroke();
        } else {
            // 其他回声（墙壁等）：白色
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath(); 
            ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); 
            ctx.stroke();
        }
    });
    ctx.globalAlpha = 1;
    
    // 绘制墙壁轮廓（穿透时显示）
    state.entities.wallEchoes.forEach(we => {
        const alpha = we.life * 0.6; // 最大透明度60%
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = we.wall.color || '#888';
        ctx.lineWidth = 2;
        ctx.strokeRect(we.wall.x, we.wall.y, we.wall.w, we.wall.h);
    });
    ctx.globalAlpha = 1;

    // 绘制波纹
    // 计算最大能量（300Hz、5度角、初始半径）
    const maxEnergySpread = 5 * Math.PI / 180; // 5度
    const maxEnergyCircumference = CFG.initialRadius * maxEnergySpread;
    // 最高频率(300Hz)的能量系数为1.5
    const maxFreqFactor = 1.5;
    const maxEnergyTotal = CFG.baseWaveEnergy * maxFreqFactor;
    const maxEnergyPerPoint = maxEnergyTotal / maxEnergyCircumference;
    
    ctx.lineWidth = 2;
    state.entities.waves.forEach(w => {
        ctx.beginPath();
        const startA = w.angle - w.spread/2; const endA = w.angle + w.spread/2;
        ctx.arc(w.x, w.y, w.r, w.spread > Math.PI*1.9 ? 0 : startA, w.spread > Math.PI*1.9 ? Math.PI*2 : endA);
        
        // 计算能量归一化值（用于视觉属性）
        const energyRatio = Math.min(1.0, w.energyPerPoint / maxEnergyPerPoint);
        
        // 使用非线性映射增强对比度（平方根让中低能量差异更明显）
        const visualRatio = Math.sqrt(energyRatio);
        
        // 同时调整饱和度、亮度和透明度
        // 饱和度：30% -> 100% （低能量保持一定饱和度，避免完全灰白）
        const saturation = Math.round(30 + visualRatio * 70);
        // 亮度：40% -> 75% （低能量较暗，高能量明亮）
        const lightness = Math.round(40 + visualRatio * 35);
        // 透明度：0.4 -> 0.95 （低能量半透明，高能量几乎不透明）
        const alpha = 0.4 + visualRatio * 0.55;
        
        // 根据波纹来源决定颜色
        let color;
        if (w.source === 'player') {
            // 玩家波纹：青色，能量影响饱和度/亮度/透明度
            color = `hsla(180, ${saturation}%, ${lightness}%, ${alpha})`;
        } else {
            // 敌人波纹：红色，能量影响饱和度/亮度/透明度
            color = `hsla(0, ${saturation}%, ${lightness}%, ${alpha})`;
        }
        
        ctx.strokeStyle = color;
        ctx.lineWidth = w.spread < 1 ? 5 : 3;
        ctx.stroke();
    });

    // 视野裁剪区
    const visPoly = getVisibiltyPolygon(state.p.x, state.p.y, state.p.a);
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(visPoly[0].x, visPoly[0].y);
    for(let i=1; i<visPoly.length; i++) ctx.lineTo(visPoly[i].x, visPoly[i].y);
    ctx.closePath();
    ctx.clip();

    // 光照
    const grad = ctx.createRadialGradient(state.p.x, state.p.y, 10, state.p.x, state.p.y, CFG.pViewDist);
    grad.addColorStop(0, 'rgba(200, 255, 255, 0.15)');
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grad; ctx.fill();

    // 实体 (墙壁, 敌人, 物品)
    state.entities.walls.forEach(w => { 
        ctx.fillStyle = w.color || '#222'; 
        ctx.strokeStyle = w.color || '#555';
        ctx.fillRect(w.x, w.y, w.w, w.h); 
        ctx.strokeRect(w.x, w.y, w.w, w.h); 
    });

    state.entities.items.forEach(i => {
        if(i.visibleTimer > 0) {
            ctx.fillStyle = '#00ff00'; ctx.shadowBlur = 10; ctx.shadowColor = '#00ff00';
            ctx.beginPath(); 
            // 简单的瓶子形状
            ctx.rect(i.x-3, i.y-6, 6, 12);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    });

    state.entities.enemies.forEach(e => {
        // 绘制敌人本体
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
        if(e.state === 'stunned') {
            ctx.fillStyle = '#333'; ctx.strokeStyle = '#555'; ctx.lineWidth = 1; ctx.stroke();
        } else {
            ctx.fillStyle = '#111'; ctx.strokeStyle = '#333'; ctx.stroke();
        }
        ctx.fill();
    });
    
    // 绘制 instructions（像贴在地板上一样，遵守视野裁剪）
    state.entities.instructions.forEach(inst => {
        // 1. 检查距离（快速过滤）
        const d = dist(inst.x, inst.y, state.p.x, state.p.y);
        if (d > CFG.pViewDist) return;
        
        // 2. 检查是否被墙壁遮挡
        if (!checkLineOfSight(state.p.x, state.p.y, inst.x, inst.y)) return;
        
        // 3. 绘制instruction
        const lines = inst.text.split('\n');
        const lineHeight = 36;
        const fontSize = 28;
        
        // 计算文本尺寸
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const textHeight = lines.length * lineHeight;
        
        // 绘制文本（白色，带黑色阴影增强可读性）
        ctx.save();
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = '#000000';
        ctx.shadowBlur = 6;
        lines.forEach((line, i) => {
            ctx.fillText(
                line,
                inst.x,
                inst.y - textHeight/2 + (i + 0.5) * lineHeight
            );
        });
        ctx.shadowBlur = 0;
        ctx.restore();
    });
    
    ctx.restore();

    // 玩家
    ctx.save();
    ctx.translate(state.p.x, state.p.y); ctx.rotate(state.p.a);
    ctx.fillStyle = state.p.invuln > 0 ? '#fff' : '#00ffff';
    ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-8, 6); ctx.lineTo(-8, -6); ctx.fill();
    
    if(state.isCharging) {
        const spread = lerp(CFG.maxSpread, CFG.minSpread, state.focusLevel);
        ctx.fillStyle = `rgba(0, 255, 255, ${0.1 + state.focusLevel*0.2})`;
        ctx.beginPath(); ctx.moveTo(0,0);
        ctx.arc(0,0, 100 + state.focusLevel*200, -spread/2, spread/2);
        ctx.fill();
    }
    ctx.restore();

    state.entities.particles.forEach(p => {
        ctx.globalAlpha = p.life; ctx.fillStyle = p.c;
        ctx.beginPath(); ctx.arc(p.x,p.y,p.s,0,Math.PI*2); ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // 恢复相机变换
    ctx.restore();
}

function rayRectIntersect(rx, ry, rdx, rdy, wx, wy, ww, wh) {
    let tMin=0, tMax=Infinity;
    if(Math.abs(rdx)<1e-5){ if(rx<wx||rx>wx+ww)return null; } else {
        let t1=(wx-rx)/rdx, t2=(wx+ww-rx)/rdx;
        tMin=Math.max(tMin, Math.min(t1,t2)); tMax=Math.min(tMax, Math.max(t1,t2));
    }
    if(Math.abs(rdy)<1e-5){ if(ry<wy||ry>wy+wh)return null; } else {
        let t1=(wy-ry)/rdy, t2=(wy+wh-ry)/rdy;
        tMin=Math.max(tMin, Math.min(t1,t2)); tMax=Math.min(tMax, Math.max(t1,t2));
    }
    if(tMin>tMax || tMax<0) return null;
    return tMin>0 ? tMin : tMax>0?tMax:null;
}

// 检测波纹与墙壁的碰撞
function checkWaveWallCollision(wave, wall) {
    // 检查波纹是否与墙壁相交
    // 对于扇形波纹，我们需要检查多个方向
    const numRays = Math.max(8, Math.ceil(wave.spread * 8 / Math.PI));
    const startAngle = wave.angle - wave.spread / 2;
    const angleStep = wave.spread / numRays;
    
    let closestHit = null;
    let closestDist = Infinity;
    let hitNormal = null;
    
    for (let i = 0; i <= numRays; i++) {
        const rayAngle = startAngle + angleStep * i;
        const dx = Math.cos(rayAngle);
        const dy = Math.sin(rayAngle);
        
        const hit = rayRectIntersect(wave.x, wave.y, dx, dy, wall.x, wall.y, wall.w, wall.h);
        // 检查碰撞点是否在波纹圆周附近（允许一定误差）
        if (hit !== null && hit > 0 && Math.abs(hit - wave.r) < CFG.waveSpeed * 2 && hit < closestDist) {
            closestDist = hit;
            const hitX = wave.x + dx * hit;
            const hitY = wave.y + dy * hit;
            
            // 计算法线方向（从墙壁中心指向碰撞点）
            const wallCenterX = wall.x + wall.w / 2;
            const wallCenterY = wall.y + wall.h / 2;
            const nx = hitX - wallCenterX;
            const ny = hitY - wallCenterY;
            const nLen = Math.hypot(nx, ny);
            
            // 确定是哪个面被击中
            const distToLeft = Math.abs(hitX - wall.x);
            const distToRight = Math.abs(hitX - (wall.x + wall.w));
            const distToTop = Math.abs(hitY - wall.y);
            const distToBottom = Math.abs(hitY - (wall.y + wall.h));
            
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            
            if (minDist === distToLeft) hitNormal = { x: -1, y: 0 };
            else if (minDist === distToRight) hitNormal = { x: 1, y: 0 };
            else if (minDist === distToTop) hitNormal = { x: 0, y: -1 };
            else hitNormal = { x: 0, y: 1 };
            
            closestHit = { x: hitX, y: hitY, dist: hit };
        }
    }
    
    if (closestHit) {
        return {
            hit: true,
            point: { x: closestHit.x, y: closestHit.y },
            dist: closestHit.dist,
            normal: hitNormal
        };
    }
    return { hit: false };
}

// 计算波纹与墙壁碰撞时被阻挡的角度范围（相对于波纹的角度）
// 返回被阻挡的角度范围数组，每个范围是相对于波纹起始角度的偏移量
function getWaveBlockedAngles(wave, wall) {
    const numRays = Math.max(32, Math.ceil(wave.spread * 32 / Math.PI)); // 增加采样精度
    const startAngle = wave.angle - wave.spread / 2;
    const angleStep = wave.spread / numRays;
    
    const blockedIndices = [];
    
    // 检查每个角度是否被阻挡
    for (let i = 0; i <= numRays; i++) {
        const rayAngle = startAngle + angleStep * i;
        const dx = Math.cos(rayAngle);
        const dy = Math.sin(rayAngle);
        
        const hit = rayRectIntersect(wave.x, wave.y, dx, dy, wall.x, wall.y, wall.w, wall.h);
        // 检查碰撞点是否在波纹圆周附近
        if (hit !== null && hit > 0 && Math.abs(hit - wave.r) < CFG.waveSpeed * 2) {
            blockedIndices.push(i);
        }
    }
    
    if (blockedIndices.length === 0) {
        return null;
    }
    
    // 将连续的索引分组为范围
    const ranges = [];
    let rangeStart = blockedIndices[0];
    let rangeEnd = blockedIndices[0];
    
    for (let i = 1; i < blockedIndices.length; i++) {
        if (blockedIndices[i] === rangeEnd + 1) {
            // 连续，扩展范围
            rangeEnd = blockedIndices[i];
        } else {
            // 不连续，保存当前范围并开始新范围
            ranges.push({
                start: (rangeStart / numRays) * wave.spread, // 转换为相对于起始角度的偏移
                end: ((rangeEnd + 1) / numRays) * wave.spread
            });
            rangeStart = blockedIndices[i];
            rangeEnd = blockedIndices[i];
        }
    }
    
    // 添加最后一个范围
    ranges.push({
        start: (rangeStart / numRays) * wave.spread,
        end: ((rangeEnd + 1) / numRays) * wave.spread
    });
    
    return ranges;
}

// 计算波纹与圆形敌人碰撞时被阻挡的角度范围
function getWaveBlockedAnglesByCircle(wave, enemy) {
    const numRays = Math.max(32, Math.ceil(wave.spread * 32 / Math.PI));
    const startAngle = wave.angle - wave.spread / 2;
    const angleStep = wave.spread / numRays;
    
    const blockedIndices = [];
    
    // 检查每个角度是否被阻挡
    for (let i = 0; i <= numRays; i++) {
        const rayAngle = startAngle + angleStep * i;
        const dx = Math.cos(rayAngle);
        const dy = Math.sin(rayAngle);
        
        // 射线与圆的相交检测
        const cx = enemy.x - wave.x;
        const cy = enemy.y - wave.y;
        
        // 计算射线方向上最接近圆心的点的距离
        const dot = cx * dx + cy * dy;
        if (dot < 0) continue; // 圆在射线后方
        
        // 最近点到圆心的距离
        const closestX = wave.x + dx * dot;
        const closestY = wave.y + dy * dot;
        const distToCenter = Math.hypot(closestX - enemy.x, closestY - enemy.y);
        
        // 如果射线穿过圆，且距离在波纹圆周附近
        if (distToCenter <= enemy.r && Math.abs(dot - wave.r) < CFG.waveSpeed * 2) {
            blockedIndices.push(i);
        }
    }
    
    if (blockedIndices.length === 0) {
        return null;
    }
    
    // 将连续的索引分组为范围
    const ranges = [];
    let rangeStart = blockedIndices[0];
    let rangeEnd = blockedIndices[0];
    
    for (let i = 1; i < blockedIndices.length; i++) {
        if (blockedIndices[i] === rangeEnd + 1) {
            rangeEnd = blockedIndices[i];
        } else {
            ranges.push({
                start: (rangeStart / numRays) * wave.spread,
                end: ((rangeEnd + 1) / numRays) * wave.spread
            });
            rangeStart = blockedIndices[i];
            rangeEnd = blockedIndices[i];
        }
    }
    
    ranges.push({
        start: (rangeStart / numRays) * wave.spread,
        end: ((rangeEnd + 1) / numRays) * wave.spread
    });
    
    return ranges;
}

function getVisibiltyPolygon(px, py, angle) {
    const points=[{x:px,y:py}]; const num=120; const fov=CFG.pViewAngle; const start=angle-fov/2; const step=fov/num;
    for(let i=0;i<=num;i++){
        const th=start+step*i; const dx=Math.cos(th); const dy=Math.sin(th);
        let cDist=CFG.pViewDist;
        for(let w of state.entities.walls){
            const d=rayRectIntersect(px,py,dx,dy,w.x,w.y,w.w,w.h);
            if(d!==null && d<cDist) cDist=d;
        }
        points.push({x:px+dx*cDist, y:py+dy*cDist});
    }
    return points;
}

// -- 辅助函数 --
function rand(min,max){return Math.random()*(max-min)+min;}
function dist(x1,y1,x2,y2){return Math.hypot(x1-x2, y1-y2);}
function clamp(v,min,max){return Math.max(min, Math.min(max, v));}
function lerp(a,b,t){return a + (b-a)*t;}
function checkWall(x, y) {
    if(x<0||x>canvas.width||y<0||y>canvas.height) return true;
    for(let w of state.entities.walls) if(x>w.x && x<w.x+w.w && y>w.y && y<w.y+w.h) return true;
    return false;
}
function checkLineOfSight(x1, y1, x2, y2) {
    const steps = Math.ceil(dist(x1,y1,x2,y2)/10); const dx=(x2-x1)/steps; const dy=(y2-y1)/steps;
    for(let i=1;i<steps;i++){
        const cx=x1+dx*i; const cy=y1+dy*i;
        for(let w of state.entities.walls) if(cx>w.x&&cx<w.x+w.w&&cy>w.y&&cy<w.y+w.h) return false;
    }
    return true;
}
function isInCone(tx, ty) {
    const d = dist(tx,ty,state.p.x,state.p.y);
    if(d > CFG.pViewDist) return false;
    const angle = Math.atan2(ty-state.p.y, tx-state.p.x);
    let diff = angle - state.p.a;
    while(diff > Math.PI) diff-=Math.PI*2;
    while(diff < -Math.PI) diff+=Math.PI*2;
    return Math.abs(diff) < CFG.pViewAngle/2;
}
function takeDamage(val) {
    if(state.p.invuln>0) return;
    state.p.hp -= val; state.p.invuln = CFG.dmgCD;
    flashScreen('red', 100);
    logMsg("WARNING: HULL DAMAGE");
    spawnParticles(state.p.x, state.p.y, '#ff0000', 10);
    if(state.p.hp<=0) { alert("SIGNAL LOST. REBOOTING..."); location.reload(); }
}
function flashScreen(color, duration) {
    screenFlash.style.backgroundColor = color; screenFlash.style.opacity = 0.6;
    setTimeout(() => screenFlash.style.opacity = 0, duration);
}
function spawnParticles(x,y,c,n) {
    for(let i=0;i<n;i++) state.entities.particles.push({x:x,y:y,vx:(Math.random()-0.5)*5,vy:(Math.random()-0.5)*5,life:1,c:c,s:Math.random()*3});
}
function logMsg(t) { document.getElementById('msg-log').innerText=t; }
function updateUI() {
    document.getElementById('hp-val').innerText = `${Math.floor(state.p.hp)}/${CFG.maxHp}`;
    document.getElementById('hp-row').style.color = state.p.hp < 30 ? 'red' : '#33ccff';
    const mainEn = Math.floor(state.p.en);
    const reserveEn = Math.floor(state.p.reserveEn || 0);
    let enText = `${mainEn}/${CFG.maxEnergy}`;
    document.getElementById('energy-val').innerText = reserveEn > 0 ? `${enText} (+${reserveEn})` : enText;
    document.getElementById('freq-box').innerText = Math.floor(state.freq) + " Hz";
}
function loop() { update(); draw(); requestAnimationFrame(loop); }
init();

</script>
</body>
</html>
